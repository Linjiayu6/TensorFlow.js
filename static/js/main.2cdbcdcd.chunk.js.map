{"version":3,"sources":["Draw.js","tensorflow.js","App.js","index.js"],"names":["svgWidth","onTensorflowToSvgPoint","_ref2","x","y","clientX","clientY","Draw","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","circleParams","r","stroke","strokeWidth","fill","width","svg","getBoundingClientRect","_ref3","onChangePoints","_ref","onSvgPointToTensorflow","_this2","_this$props$points","points","length","map","item","key","_onTensorflowToSvgPoi","react_default","a","createElement","assign","cx","cy","_this$props","tfPredict","xs","ys","dataSync","_onTensorflowToSvgPoi2","x1","y1","_onTensorflowToSvgPoi3","lineProps","x2","y2","_this3","ref","e","height","style","background","onClick","onAddCircle","renderDrawCircle","renderDrawLine","Component","tf","Math","random","b","predict","mul","add","model","loss","predictYs","sub","square","mean","tensorflow","training","trainTimes","_loop","optimizer","sgd","console","log","toString","minimize","i","App","newPoints","setState","concat","toConsumableArray","nextProps","nextState","className","src_Draw","linePoint","ReactDOM","render","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.2cdbcdcd.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nlet svgWidth = 500;\nconst svgHeight = 500;\n\n// 我们希望训练模型的数据均是在 0 - 1区间数值, 按照我们对当前图形传入值, 以及坐标位置变更, 需要做一次数据的转化。\nconst onSvgPointToTensorflow = ({ clientX, clientY }) => ({\n  x: clientX / svgWidth,\n  y: (svgHeight - clientY) / svgHeight\n})\n\n// 还原至svg需要展示的点\nconst onTensorflowToSvgPoint = ({ x, y }) => ({\n  clientX: x * svgWidth,\n  clientY: (1 - y) * svgHeight\n})\n\nclass Draw extends Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      circleParams: {\n        r: 3,\n        stroke: '#fff',\n        strokeWidth: 1,\n        fill: '#fff'\n      }\n    }\n  }\n\n  componentDidMount () {\n    const { width } = this.svg.getBoundingClientRect()\n    svgWidth = width\n  }\n\n  // 点击圆圈操作 将数据传入至state中\n  onAddCircle ({ clientX, clientY }) {\n    const { onChangePoints } = this.props\n    const newPoints = onSvgPointToTensorflow({ clientX, clientY })\n    onChangePoints(newPoints)\n  }\n\n  // svg-circle 画圆圈\n  renderDrawCircle () {\n    if (this.svg) {\n      const { points = [] } = this.props\n      if (points && points.length) {\n        return points.map((item, key) => {\n          const { clientX, clientY } = onTensorflowToSvgPoint(item)\n          return <circle key={key} cx={clientX} cy={clientY} {... this.state.circleParams } />  \n        })\n      }\n    }\n  }\n\n  // svg-line 画线\n  renderDrawLine () {\n    const { tfPredict, points } = this.props\n    // points.length < 2 && \n    if (points && points.length < 2) return\n    const xs = [0, 1] // 两个点\n    const ys = tfPredict(xs).dataSync() // 同步 https://js.tensorflow.org/api/latest/index.html#tf.Tensor.data\n    const { clientX: x1, clientY: y1 } = onTensorflowToSvgPoint({ x: xs[0], y: ys[0] })\n    const { clientX: x2, clientY: y2 } = onTensorflowToSvgPoint({ x: xs[1], y: ys[1] })\n    const lineProps = { x1, y1, x2, y2 }\n    return (\n      <line { ...lineProps } stroke=\"red\" strokeWidth=\"2\" />\n    )\n  }\n\n  // svg-画布\n  render () {\n    return (\n      <svg\n        ref={e => (this.svg = e)}\n        width=\"100%\"\n        height={svgHeight}\n        style={{ background: \"#282c34\" }}\n        onClick={e => this.onAddCircle(e)}\n      >\n        { this.renderDrawCircle() }\n        { this.renderDrawLine() }\n      </svg>\n    )\n  }\n}\n\nexport default Draw\n","\nimport * as tf from '@tensorflow/tfjs'\n// https://js.tensorflow.org/tutorials/fit-curve.html\n\n// y = ax + b\n// 这里初始化a, b为随机数, 因为我们是需要a, b\n// 这里我们是从一个随机数开始的。也就意味着, 我们需要大量的训练才能计算出真正符合当前模型的值\nlet a = tf.variable(tf.scalar(Math.random()))\nlet b = tf.variable(tf.scalar(Math.random()))\n\n// 建立模型\nconst model = (xs, a, b) => xs.mul(a).add(b)\n\n// 1. training, y值\nconst training = (points, trainTimes) => {\n  for (var i = 0; i < trainTimes; i++) {\n    // 4. 优化器 https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/518746/\n    // 因為大多數機器學習任務就是最小化損失\n    // 学习率: \n    const learningRate = 0.1\n    const optimizer = tf.train.sgd(learningRate);\n    // ========================================================================\n\n    const ys = tf.tensor1d(points.map(points => points.y))\n    console.log('输入y', ys.toString())\n    // const predictYs = predict(points.map((points) => points.x))\n    // console.log('预测值', predictYs.toString())\n\n    // 训练一次, 计算有损函数\n    // 机器学习就是一个不断训练、评价迭代的模型训练过程，训练得越好，则未来预测得越准确。\n    // 一次肯定是不够的, 而且我们还需要明确的是, 将损失降到最低\n    // const lossFn = loss(predictYs, ys)\n    // console.log('均方差值', lossFn.toString())\n\n    // 优化器优化的是 如何去把损失降低到最低\n    optimizer.minimize(() => loss(predict(points.map((points) => points.x)), ys));\n  }\n}\n\n// 2. predict, x值输入, 线性方程 y = ax + b\nconst predict = x => {\n  // tf.tidy防止内存泄露: https://js.tensorflow.org/api/0.11.7/ \n  return tf.tidy(() => {\n    const xs = tf.tensor1d(x)\n    // 预测的y值 建立模型\n    const predictYs = model(xs, a, b)\n    return predictYs\n  })\n}\n\n// 3. 评价过程, 也是损失函数: 均方差 求出最小的\n// 根据预测值和实际标签值，计算出一个评价值，值越小说明当前模型拟合得越好，默认提供的是均方误差（mean squared error），其实就是将每一个预测值减去标签值然后进行平方，求这个平方的平均值。\nconst loss = (predictYs, ys) => predictYs.sub(ys).square().mean()\n\nexport default {\n  training, predict\n}\n","import React, { Component } from 'react'\n\nimport './assets/App.css'\nimport Draw from './Draw'\n\nimport tensorflow from './tensorflow'\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      points: [], // 所有收集的点\n      trainTimes: 10 // 一次数据, 训练10次\n    };\n  }\n\n  // 点击后, 收集数据\n  onChangePoints (newPoints) {\n    this.setState({ points: [ ...this.state.points, newPoints] })\n  }\n\n  shouldComponentUpdate (nextProps, nextState) {\n    // 将输入的内容, 放到模型里面去训练\n    if (nextState.points && nextState.points.length > 1) {\n        tensorflow.training(nextState.points, nextState.trainTimes)\n    }\n    return true\n  }\n\n  render () {\n    const { points } = this.state\n    return (\n      <div className=\"app\">\n        <Draw\n          onChangePoints={(newPoints) => this.onChangePoints(newPoints)}\n          points={points}\n          tfPredict={(linePoint) => tensorflow.predict(linePoint)}\n        />\n        <div >[线性回归模拟] 请在屏幕上点击 </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './assets/index.css';\nimport App from './App';\n// import * as serviceWorker from './tools/serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}