{"version":3,"sources":["Draw.js","Content.js","tensorflow.js","App.js","index.js"],"names":["svgWidth","onTensorflowToSvgPoint","_ref2","x","y","clientX","clientY","Draw","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","circleParams","r","stroke","strokeWidth","fill","width","svg","getBoundingClientRect","_ref3","onChangePoints","_ref","onSvgPointToTensorflow","_this2","_this$props$points","points","length","map","item","key","_onTensorflowToSvgPoi","react_default","a","createElement","assign","cx","cy","_this$props","tfPredict","isTraining","xs","ys","dataSync","_onTensorflowToSvgPoi2","x1","y1","_onTensorflowToSvgPoi3","lineProps","x2","y2","_this3","ref","e","height","style","background","onClick","onAddCircle","renderDrawCircle","renderDrawLine","Component","Content","onClickBtn","onResetBtn","className","concat","window","b","tf","Math","random","predict","mul","add","model","loss","predictYs","sub","square","mean","tensorflow","training","trainTimes","_loop","optimizer","sgd","console","log","toString","minimize","i","App","nextProps","nextState","newPoints","setState","toConsumableArray","_this$state","src_Draw","linePoint","ReactDOM","render","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.0f24fd61.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nlet svgWidth = 500;\nconst svgHeight = 400;\n\n// 我们希望训练模型的数据均是在 0 - 1区间数值, 按照我们对当前图形传入值, 以及坐标位置变更, 需要做一次数据的转化。\nconst onSvgPointToTensorflow = ({ clientX, clientY }) => ({\n  x: clientX / svgWidth,\n  y: (svgHeight - clientY) / svgHeight\n})\n\n// 还原至svg需要展示的点\nconst onTensorflowToSvgPoint = ({ x, y }) => ({\n  clientX: x * svgWidth,\n  clientY: (1 - y) * svgHeight\n})\n\nclass Draw extends Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      circleParams: {\n        r: 3,\n        stroke: '#fff',\n        strokeWidth: 1,\n        fill: '#fff'\n      }\n    }\n  }\n\n  componentDidMount () {\n    const { width } = this.svg.getBoundingClientRect()\n    svgWidth = width\n  }\n\n  // 点击圆圈操作 将数据传入至state中\n  onAddCircle ({ clientX, clientY }) {\n    const { onChangePoints } = this.props\n    const newPoints = onSvgPointToTensorflow({ clientX, clientY })\n    onChangePoints(newPoints)\n  }\n\n  // svg-circle 画圆圈\n  renderDrawCircle () {\n    if (this.svg) {\n      const { points = [] } = this.props\n      if (points && points.length) {\n        return points.map((item, key) => {\n          const { clientX, clientY } = onTensorflowToSvgPoint(item)\n          return <circle key={key} cx={clientX} cy={clientY} {... this.state.circleParams } />  \n        })\n      }\n    }\n  }\n\n  // svg-line 画线\n  renderDrawLine () {\n    const { tfPredict, points, isTraining } = this.props\n    // points.length < 2 && \n    if (!isTraining || (points && points.length < 2)) return\n    const xs = [0, 1] // 两个点\n    const ys = tfPredict(xs).dataSync() // 同步 https://js.tensorflow.org/api/latest/index.html#tf.Tensor.data\n    const { clientX: x1, clientY: y1 } = onTensorflowToSvgPoint({ x: xs[0], y: ys[0] })\n    const { clientX: x2, clientY: y2 } = onTensorflowToSvgPoint({ x: xs[1], y: ys[1] })\n    const lineProps = { x1, y1, x2, y2 }\n    return (\n      <line { ...lineProps } stroke=\"red\" strokeWidth=\"2\" />\n    )\n  }\n\n  // svg-画布\n  render () {\n    return (\n      <svg\n        ref={e => (this.svg = e)}\n        width=\"100%\"\n        height={svgHeight}\n        style={{ background: \"#282c34\" }}\n        onClick={e => this.onAddCircle(e)}\n      >\n        { this.renderDrawCircle() }\n        { this.renderDrawLine() }\n      </svg>\n    )\n  }\n}\n\nexport default Draw\n","\nimport React from 'react'\n\nexport default ({ points, isTraining, onClickBtn, onResetBtn }) => {\n  return (\n    <div>\n      <div className=\"steps\">\n      <p>[目标] 通过在屏幕上点击的离散点, 训练线性模型(y = ax + b), 最后可对某输入值进行输出值的预测</p>\n      <p>1.[数据收集] 请点击屏幕, 已有n个点后, 点击Button进行模型训练 *请点击至少2个点</p>\n      <p>2.[模型训练] 可视的红线 为已训练模型</p>\n      <p>3.[预测] 根据已训练的模型, 进行预测 </p>\n    </div>\n    <div className=\"contents\">\n      <p>共有 {points && points.length} 个数据(已点击点数) </p>\n      <div>\n        <button className=\"button\" onClick={onClickBtn}>模型训练 Training</button>\n        <button className=\"button btnreset\" onClick={onResetBtn}>数据Reset</button>\n      </div>\n      <div>训练后模型为: {isTraining && (points && points.length > 1) ? `Y = ${window.a} X + ${window.b}` : ''}</div>\n    </div>\n    </div>\n  )\n}","\nimport * as tf from '@tensorflow/tfjs'\n// https://js.tensorflow.org/tutorials/fit-curve.html\n\n// y = ax + b\n// 这里初始化a, b为随机数, 因为我们是需要a, b\n// 这里我们是从一个随机数开始的。也就意味着, 我们需要大量的训练才能计算出真正符合当前模型的值\nwindow.a = tf.variable(tf.scalar(Math.random()))\nwindow.b = tf.variable(tf.scalar(Math.random()))\n\n// 建立模型\nconst model = (xs, a, b) => xs.mul(a).add(b)\n\n// 1. training, y值\nconst training = ({ points, trainTimes }) => {\n  for (var i = 0; i < trainTimes; i++) {\n    // 4. 优化器 https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/518746/\n    // 因為大多數機器學習任務就是最小化損失\n    // 学习率: \n    const learningRate = 0.1\n    const optimizer = tf.train.sgd(learningRate);\n    // ========================================================================\n\n    const ys = tf.tensor1d(points.map(points => points.y))\n    console.log('输入y', ys.toString())\n    // const predictYs = predict(points.map((points) => points.x))\n    // console.log('预测值', predictYs.toString())\n\n    // 训练一次, 计算有损函数\n    // 机器学习就是一个不断训练、评价迭代的模型训练过程，训练得越好，则未来预测得越准确。\n    // 一次肯定是不够的, 而且我们还需要明确的是, 将损失降到最低\n    // const lossFn = loss(predictYs, ys)\n    // console.log('均方差值', lossFn.toString())\n\n    // 优化器优化的是 如何去把损失降低到最低\n    optimizer.minimize(() => loss(predict(points.map((points) => points.x)), ys));\n  }\n}\n\n// 2. predict, x值输入, 线性方程 y = ax + b\nconst predict = x => {\n  // tf.tidy防止内存泄露: https://js.tensorflow.org/api/0.11.7/ \n  return tf.tidy(() => {\n    const xs = tf.tensor1d(x)\n    // 预测的y值 建立模型\n    const predictYs = model(xs, window.a, window.b)\n    return predictYs\n  })\n}\n\n// 3. 评价过程, 也是损失函数: 均方差 求出最小的\n// 根据预测值和实际标签值，计算出一个评价值，值越小说明当前模型拟合得越好，默认提供的是均方误差（mean squared error），其实就是将每一个预测值减去标签值然后进行平方，求这个平方的平均值。\nconst loss = (predictYs, ys) => predictYs.sub(ys).square().mean()\n\nexport default {\n  training, predict\n}\n","import React, { Component } from 'react'\n\nimport './assets/App.css'\nimport Draw from './Draw'\nimport Content from './Content'\n\nimport tensorflow from './tensorflow'\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      a: 0,\n      b: 0,\n      points: [], // 所有收集的点\n      trainTimes: 100, // 一次数据, 训练 100次,\n      isTraining: false // 是否开始训练\n    };\n  }\n\n  shouldComponentUpdate (nextProps, nextState) {\n    const { points, trainTimes } = nextState\n    // 将输入的内容, 放到模型里面去训练\n    if (points && points.length > 1) {\n        tensorflow.training({ points, trainTimes })\n    }\n    return true\n  }\n\n  // 点击后, 收集数据\n  onChangePoints (newPoints) {\n    this.setState({ points: [ ...this.state.points, newPoints] })\n  }\n\n  onSetState (item) {\n    this.setState(item)\n  }\n\n  render () {\n    const { points, isTraining } = this.state\n    return (\n      <div className=\"app\">\n        <Draw\n          onChangePoints={(newPoints) => this.onChangePoints(newPoints)}\n          points={points}\n          tfPredict={(linePoint) => tensorflow.predict(linePoint)}\n          isTraining={isTraining}\n        />\n        <Content\n          isTraining={isTraining}\n          points={points}\n          onClickBtn={() => this.setState({ isTraining: true }) }\n          onResetBtn={() => this.setState({ isTraining: false, points: [] }) }\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './assets/index.css';\nimport App from './App';\n// import * as serviceWorker from './tools/serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}