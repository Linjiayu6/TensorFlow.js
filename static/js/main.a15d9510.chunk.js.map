{"version":3,"sources":["Draw.js","tensorflow.js","App.js","index.js"],"names":["onTensorflowToSvgPoint","_ref2","clientX","x","clientY","y","Draw","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","circleParams","r","stroke","strokeWidth","fill","_ref","_ref3","onChangePoints","_this2","svg","_this$props$points","points","length","map","item","key","_onTensorflowToSvgPoi","react_default","a","createElement","assign","cx","cy","_this$props","tfPredict","xs","ys","dataSync","_onTensorflowToSvgPoi2","x1","y1","_onTensorflowToSvgPoi3","lineProps","x2","y2","_this3","ref","e","width","height","style","background","onMouseDown","onAddCircle","renderDrawCircle","renderDrawLine","Component","tf","Math","random","b","predict","mul","add","model","loss","predictYs","sub","square","mean","tensorflow","training","trainTimes","_loop","optimizer","sgd","console","log","toString","minimize","i","App","newPoints","setState","concat","toConsumableArray","nextProps","nextState","className","src_Draw","linePoint","ReactDOM","render","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.a15d9510.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nconst svgWidth = 500;\nconst svgHeight = 500;\n\n// 我们希望训练模型的数据均是在 0 - 1区间数值, 按照我们对当前图形传入值, 以及坐标位置变更, 需要做一次数据的转化。\nconst onSvgPointToTensorflow = ({ clientX, clientY }) => ({\n  x: clientX / svgWidth,\n  y: (svgHeight - clientY) / svgHeight\n})\n\n// 还原至svg需要展示的点\nconst onTensorflowToSvgPoint = ({ x, y }) => ({\n  clientX: x * svgWidth,\n  clientY: (1 - y) * svgHeight\n})\n\nclass Draw extends Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      circleParams: {\n        r: 3,\n        stroke: '#fff',\n        strokeWidth: 1,\n        fill: '#fff'\n      }\n    }\n  }\n  // 点击圆圈操作 将数据传入至state中\n  onAddCircle ({ clientX, clientY }) {\n    const { onChangePoints } = this.props\n    const newPoints = onSvgPointToTensorflow({ clientX, clientY })\n    onChangePoints(newPoints)\n  }\n\n  // svg-circle 画圆圈\n  renderDrawCircle () {\n    if (this.svg) {\n      const { points = [] } = this.props\n      if (points && points.length) {\n        return points.map((item, key) => {\n          const { clientX, clientY } = onTensorflowToSvgPoint(item)\n          return <circle key={key} cx={clientX} cy={clientY} {... this.state.circleParams } />  \n        })\n      }\n    }\n  }\n\n  // svg-line 画线\n  renderDrawLine () {\n    const { tfPredict, points } = this.props\n    // points.length < 2 && \n    if (points && points.length < 2) return\n    const xs = [0, 1] // 两个点\n    const ys = tfPredict(xs).dataSync() // 同步 https://js.tensorflow.org/api/latest/index.html#tf.Tensor.data\n    const { clientX: x1, clientY: y1 } = onTensorflowToSvgPoint({ x: xs[0], y: ys[0] })\n    const { clientX: x2, clientY: y2 } = onTensorflowToSvgPoint({ x: xs[1], y: ys[1] })\n    const lineProps = { x1, y1, x2, y2 }\n    return (\n      <line { ...lineProps } stroke=\"red\" strokeWidth=\"2\" />\n    )\n  }\n\n  // svg-画布\n  render () {\n    return (\n      <svg\n        ref={e => (this.svg = e)}\n        width={svgWidth}\n        height={svgHeight}\n        style={{ background: \"#282c34\" }}\n        onMouseDown={e => this.onAddCircle(e)}\n      >\n        { this.renderDrawCircle() }\n        { this.renderDrawLine() }\n      </svg>\n    )\n  }\n}\n\nexport default Draw\n","\nimport * as tf from '@tensorflow/tfjs'\n// https://js.tensorflow.org/tutorials/fit-curve.html\n\n// y = ax + b\n// 这里初始化a, b为随机数, 因为我们是需要a, b\n// 这里我们是从一个随机数开始的。也就意味着, 我们需要大量的训练才能计算出真正符合当前模型的值\nlet a = tf.variable(tf.scalar(Math.random()))\nlet b = tf.variable(tf.scalar(Math.random()))\n\n// 建立模型\nconst model = (xs, a, b) => xs.mul(a).add(b)\n\n// 1. training, y值\nconst training = (points, trainTimes) => {\n  for (var i = 0; i < trainTimes; i++) {\n    // 4. 优化器 https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/518746/\n    // 因為大多數機器學習任務就是最小化損失\n    // 学习率: \n    const learningRate = 0.1\n    const optimizer = tf.train.sgd(learningRate);\n    // ========================================================================\n\n    const ys = tf.tensor1d(points.map(points => points.y))\n    console.log('输入y', ys.toString())\n    // const predictYs = predict(points.map((points) => points.x))\n    // console.log('预测值', predictYs.toString())\n\n    // 训练一次, 计算有损函数\n    // 机器学习就是一个不断训练、评价迭代的模型训练过程，训练得越好，则未来预测得越准确。\n    // 一次肯定是不够的, 而且我们还需要明确的是, 将损失降到最低\n    // const lossFn = loss(predictYs, ys)\n    // console.log('均方差值', lossFn.toString())\n\n    // 优化器优化的是 如何去把损失降低到最低\n    optimizer.minimize(() => loss(predict(points.map((points) => points.x)), ys));\n  }\n}\n\n// 2. predict, x值输入, 线性方程 y = ax + b\nconst predict = x => {\n  // tf.tidy防止内存泄露: https://js.tensorflow.org/api/0.11.7/ \n  return tf.tidy(() => {\n    const xs = tf.tensor1d(x)\n    // 预测的y值 建立模型\n    const predictYs = model(xs, a, b)\n    return predictYs\n  })\n}\n\n// 3. 评价过程, 也是损失函数: 均方差 求出最小的\n// 根据预测值和实际标签值，计算出一个评价值，值越小说明当前模型拟合得越好，默认提供的是均方误差（mean squared error），其实就是将每一个预测值减去标签值然后进行平方，求这个平方的平均值。\nconst loss = (predictYs, ys) => predictYs.sub(ys).square().mean()\n\nexport default {\n  training, predict\n}\n","import React, { Component } from 'react'\n\nimport './assets/App.css'\nimport Draw from './Draw'\n\nimport tensorflow from './tensorflow'\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      points: [], // 所有收集的点\n      trainTimes: 10 // 一次数据, 训练10次\n    };\n  }\n\n  // 点击后, 收集数据\n  onChangePoints (newPoints) {\n    this.setState({ points: [ ...this.state.points, newPoints] })\n  }\n\n  shouldComponentUpdate (nextProps, nextState) {\n    // 将输入的内容, 放到模型里面去训练\n    if (nextState.points && nextState.points.length > 1) {\n        tensorflow.training(nextState.points, nextState.trainTimes)\n    }\n    return true\n  }\n\n  render () {\n    const { points } = this.state\n    return (\n      <div className=\"app\">\n        <Draw\n          onChangePoints={(newPoints) => this.onChangePoints(newPoints)}\n          points={points}\n          tfPredict={(linePoint) => tensorflow.predict(linePoint)}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './assets/index.css';\nimport App from './App';\n// import * as serviceWorker from './tools/serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}